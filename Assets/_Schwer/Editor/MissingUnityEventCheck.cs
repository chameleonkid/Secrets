using System;
using System.Reflection;
using UnityEditor;
using UnityEngine;
using UnityEngine.Events;

[CustomEditor(typeof(MonoBehaviour))]
public class MissingUnityEventCheck : Editor {
    // Reference: https://stackoverflow.com/questions/42784338/unity-missing-warning-when-button-has-missing-onclick
    
    private const string prefix = "MUEC";

    [MenuItem("Tools/Check Unity Events")]
    public static void CheckUnityEvents() {
        var loadedMonoBehaviours = Resources.FindObjectsOfTypeAll<MonoBehaviour>();
        Debug.Log(prefix + ": Found " + loadedMonoBehaviours.Length + " loaded MonoBehaviours.");

        for (int i = 0; i < loadedMonoBehaviours.Length; i++) {
            CheckMonoBehaviour(loadedMonoBehaviours[i]);
        }

        Debug.Log("MUEC: Done.");
    }

    private static void CheckMonoBehaviour(MonoBehaviour mb) {
        var fields = mb.GetType().GetFields();
        // ^ If my reading is correct, this will only find `public` fields.
        // May need to modify to accomodate properties and non-public members.
        for (int i = 0; i < fields.Length; i++) {
            if (fields[i].FieldType == typeof(UnityEvent)) {
                var unityEvent = fields[i].GetValue(mb) as UnityEvent;
                for (int j = 0; j < unityEvent.GetPersistentEventCount(); j++) {
                    var target = unityEvent.GetPersistentTarget(j);
                    var method = unityEvent.GetPersistentMethodName(j);

                    var targetTypeFullName = target.GetType().FullName;
                    var mbType = mb.GetType();
                    var mbName = mb.gameObject.name;
                    
                    if (target == null) {
                        Debug.Log(prefix + ": " + mbName + ": " + mbType + "." + fields[i].Name + " has no target.", mb);
                    }
                    else if (!TypeExists(targetTypeFullName)) {
                        Debug.Log(prefix + ": " + mbName + ": " + mbType + "." + fields[i].Name + " target type (" + targetTypeFullName + ") missing.", mb);
                    }
                    //! ^ Seems to report false positives. May be an issue with how assemblies are generated by Unity
                    //! > If the assembly has not been saved to disk when `GetType` is called, the method returns `null`.
                    //! Reference: https://docs.microsoft.com/en-us/dotnet/api/system.type.gettype?view=net-5.0#System_Type_GetType_System_String_
                    else if (MethodIsPublic(target, method)) {
                        // No need to log.
                        // Need to leave this condition in case
                        // target class has public and non-public
                        // methods with the same name.
                    }
                    else if (MethodIsNonPublic(target, method)) {
                        Debug.Log(prefix + ": " + mbName + ": " + mbType + "." + fields[i].Name + " target method (" + targetTypeFullName + "." + method + ") is not public.", mb);
                    }
                    else {
                        Debug.Log(prefix + ": " + mbName + ": " + mbType + "." + fields[i].Name + " target method (" + targetTypeFullName + "." + method + ") does not exist.", mb);
                    }
                }
            }
        }
    }

    private static bool TypeExists(string typeName) => Type.GetType(typeName) != null;
    private static bool MethodIsPublic(UnityEngine.Object target, string methodName) => target.GetType().GetMethod(methodName) != null;
    private static bool MethodIsNonPublic(UnityEngine.Object target, string methodName) => target.GetType().GetMethod(methodName, BindingFlags.Instance | BindingFlags.NonPublic) != null;
}
